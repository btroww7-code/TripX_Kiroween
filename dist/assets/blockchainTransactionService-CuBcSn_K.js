import{f as E,c as $,h as y,a as I}from"./index-s9rZPGJJ.js";const w="0x6A19B0E01cB227B9fcc7eD95b8f13D2894d63Ffd",x="0xFc22556bb4ae5740610bE43457d46AdA5200b994",D="0x110D62545d416d3DFEfA12D0298aBf197CF0e828",P=["https://ethereum-sepolia.publicnode.com","https://rpc.sepolia.org","https://ethereum-sepolia-rpc.publicnode.com","https://1rpc.io/sepolia"],C=[{type:"event",name:"Transfer",inputs:[{name:"from",type:"address",indexed:!0},{name:"to",type:"address",indexed:!0},{name:"value",type:"uint256",indexed:!1}]}],F=[{type:"event",name:"Transfer",inputs:[{name:"from",type:"address",indexed:!0},{name:"to",type:"address",indexed:!0},{name:"tokenId",type:"uint256",indexed:!0}]}],N=new Map,R=120*1e3;function _(){for(const r of P)try{return $({chain:I,transport:y(r,{timeout:15e3,fetchOptions:{signal:AbortSignal.timeout(15e3)}})})}catch(u){console.warn(`[blockchainTransactionService] Failed to create client with ${r}:`,u);continue}throw new Error("Failed to create public client with any RPC provider")}async function X(r,u=100){var m;if(!r||!w)return console.warn("[blockchainTransactionService] Missing wallet address or TPX contract address"),[];const l=`tpx_${r.toLowerCase()}_${u}`,f=N.get(l);if(f&&Date.now()-f.timestamp<R)return console.log("[blockchainTransactionService] Returning cached TPX transactions"),f.data;try{const a=_(),n=r.toLowerCase(),i=await a.getBlockNumber(),s=45e3,k=2e5;let T=i>BigInt(k)?i-BigInt(k):0n;console.log("[blockchainTransactionService] Fetching TPX transfers for:",n);const p=Number(i-T);console.log(`[blockchainTransactionService] Block range: ${T} to ${i} (${p} blocks, will split into chunks of ${s})`);let d=[],t=T;const c=i;for(;t<c;){const e=t+BigInt(s)>c?c:t+BigInt(s);try{const o=await a.getLogs({address:w,event:C[0],args:{to:n},fromBlock:t,toBlock:e});d=d.concat(o),console.log(`[blockchainTransactionService] Found ${o.length} transfers in range ${t}-${e}`),t=e+1n}catch(o){if((m=o.message)!=null&&m.includes("exceed maximum block range")){const g=Math.floor(s/2),h=t+BigInt(g)>c?c:t+BigInt(g),S=await a.getLogs({address:w,event:C[0],args:{to:n},fromBlock:t,toBlock:h});d=d.concat(S),t=h+1n}else throw o}}const B=d;console.log(`[blockchainTransactionService] Found ${B.length} total TPX transfer events`);const b=(await Promise.all(B.slice(0,u).map(async e=>{try{const o=await a.getTransaction({hash:e.transactionHash}),g=await a.getBlock({blockNumber:e.blockNumber});return{txHash:e.transactionHash,from:(e.args.from||"").toLowerCase(),to:(e.args.to||"").toLowerCase(),amount:parseFloat(E(e.args.value||0n,18)),blockNumber:e.blockNumber,timestamp:Number(g.timestamp),contractAddress:w}}catch(o){return console.warn("[blockchainTransactionService] Error processing TPX transfer log:",o),null}}))).filter(e=>e!==null);return b.sort((e,o)=>Number(o.blockNumber-e.blockNumber)),N.set(l,{data:b,timestamp:Date.now()}),b}catch(a){return console.error("[blockchainTransactionService] Error fetching TPX transactions:",a),[]}}async function M(r,u=100){var a;if(!r)return console.warn("[blockchainTransactionService] Missing wallet address"),[];const l=[];if(l.push(x),l.push(D),l.length===0)return console.warn("[blockchainTransactionService] No NFT contract addresses configured"),[];console.log("[blockchainTransactionService] Checking NFT contracts:",l);const f=`nft_${r.toLowerCase()}_${u}`,m=N.get(f);if(m&&Date.now()-m.timestamp<R)return console.log("[blockchainTransactionService] Returning cached NFT transactions:",m.data.length),m.data;console.log("[blockchainTransactionService] Cache expired or not found, fetching fresh data");try{const n=_(),i=r.toLowerCase(),s=await n.getBlockNumber(),k=45e3,T=2e5;let p=s>BigInt(T)?s-BigInt(T):0n;console.log("[blockchainTransactionService] Fetching NFT transfers for:",i);const d=Number(s-p);console.log(`[blockchainTransactionService] Block range: ${p} to ${s} (${d} blocks, will split into chunks of ${k})`);let t=[];const c=s;for(const e of l){console.log(`[blockchainTransactionService] Checking contract: ${e}`);let o=p;for(;o<c;){const g=o+BigInt(k)>c?c:o+BigInt(k);try{const h=await n.getLogs({address:e,event:F[0],args:{to:i},fromBlock:o,toBlock:g});t=t.concat(h),console.log(`[blockchainTransactionService] Found ${h.length} NFT transfers from ${e} in range ${o}-${g}`),o=g+1n}catch(h){if((a=h.message)!=null&&a.includes("exceed maximum block range")){const S=Math.floor(k/2),v=o+BigInt(S)>c?c:o+BigInt(S),A=await n.getLogs({address:e,event:F[0],args:{to:i},fromBlock:o,toBlock:v});t=t.concat(A),o=v+1n}else{console.warn(`[blockchainTransactionService] Error fetching logs for ${e}:`,h);break}}}}const B=t;console.log(`[blockchainTransactionService] Found ${B.length} total NFT transfer events`);const b=(await Promise.all(B.slice(0,u).map(async e=>{try{const o=await n.getBlock({blockNumber:e.blockNumber});return{txHash:e.transactionHash,from:(e.args.from||"").toLowerCase(),to:(e.args.to||"").toLowerCase(),tokenId:Number(e.args.tokenId||0n),blockNumber:e.blockNumber,timestamp:Number(o.timestamp),contractAddress:e.address.toLowerCase()}}catch(o){return console.warn("[blockchainTransactionService] Error processing NFT transfer log:",o),null}}))).filter(e=>e!==null);return b.sort((e,o)=>Number(o.blockNumber-e.blockNumber)),N.set(f,{data:b,timestamp:Date.now()}),b}catch(n){return console.error("[blockchainTransactionService] ‚ùå Error fetching NFT transactions:",n),console.error("[blockchainTransactionService] Error details:",{message:n.message,stack:n.stack,name:n.name}),[]}}function H(){N.clear(),console.log("[blockchainTransactionService] Cache cleared")}export{H as clearTransactionCache,M as getBlockchainNFTTransactions,X as getBlockchainTokenTransactions};
